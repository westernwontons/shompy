// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
static DATAMODEL_STR : & 'static str = "datasource db {\n  provider = \"postgres\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"cargo prisma\"\n  output   = \"../ui/src/prisma.rs\"\n}\n\nmodel Food {\n  id        Int      @id @default(autoincrement())\n  food_type String   @db.VarChar(20)\n  name      String   @db.VarChar(200)\n  price     Float    @db.Real\n  date      DateTime @db.Date\n}\n" ;
static DATABASE_STR: &'static str = "postgres";
pub async fn new_client(
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
  let config =
    ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?
      .subject;
  let source = config
    .datasources
    .first()
    .expect("Please supply a datasource in your schema.prisma file");
  let url = if let Some(url) = source.load_shadow_database_url()? {
    url
  } else {
    source.load_url(|key| std::env::var(key).ok())?
  };
  let url = if url.starts_with("file:") {
    let path = url.split(":").nth(1).unwrap();
    if std::path::Path::new("./schema.prisma").exists() {
      url
    } else if std::path::Path::new("./prisma/schema.prisma").exists() {
      format!("file:./prisma/{}", path)
    } else {
      url
    }
  } else {
    url
  };
  new_client_with_url(&url).await
}
pub async fn new_client_with_url(
  url: &str
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
  let config =
    ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?
      .subject;
  let source = config
    .datasources
    .first()
    .expect("Please supply a datasource in your schema.prisma file");
  let (db_name, executor) =
    ::prisma_client_rust::query_core::executor::load(&source, &[], &url)
      .await?;
  let internal_model =
    ::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(
      DATAMODEL_STR
    )
    .build(db_name);
  let query_schema =
    std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
      internal_model,
      true,
      source.capabilities(),
      vec![],
      source.referential_integrity()
    ));
  executor.primary_connector().get_connection().await?;
  Ok(PrismaClient::_new(executor, query_schema))
}
pub mod food {
  use super::_prisma::*;
  use super::*;
  pub mod id {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam
    };
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: i32) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: i32) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: i32) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: i32) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn not(value: i32) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub struct Set(pub i32);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Id(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("id").build()
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Id(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("id").build()
      }
    }
  }
  pub mod food_type {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::FoodTypeEquals(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::FoodType(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::FoodTypeInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::FoodTypeNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::FoodTypeLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::FoodTypeLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::FoodTypeGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::FoodTypeGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::FoodTypeContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::FoodTypeStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::FoodTypeEndsWith(value)
    }
    pub fn mode(value: QueryMode) -> WhereParam {
      WhereParam::FoodTypeMode(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::FoodTypeNot(value)
    }
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetFoodType(value.0)
      }
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::FoodType(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("food_type").build()
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::FoodType(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("food_type").build()
      }
    }
  }
  pub mod name {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam
    };
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::NameEquals(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::NameLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::NameLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::NameGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::NameGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::NameContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::NameStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::NameEndsWith(value)
    }
    pub fn mode(value: QueryMode) -> WhereParam {
      WhereParam::NameMode(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::NameNot(value)
    }
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Name(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("name").build()
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Name(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("name").build()
      }
    }
  }
  pub mod price {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam
    };
    pub fn set<T: From<Set>>(value: f64) -> T {
      Set(value).into()
    }
    pub fn equals(value: f64) -> WhereParam {
      WhereParam::PriceEquals(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Price(direction)
    }
    pub fn in_vec(value: Vec<f64>) -> WhereParam {
      WhereParam::PriceInVec(value)
    }
    pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
      WhereParam::PriceNotInVec(value)
    }
    pub fn lt(value: f64) -> WhereParam {
      WhereParam::PriceLt(value)
    }
    pub fn lte(value: f64) -> WhereParam {
      WhereParam::PriceLte(value)
    }
    pub fn gt(value: f64) -> WhereParam {
      WhereParam::PriceGt(value)
    }
    pub fn gte(value: f64) -> WhereParam {
      WhereParam::PriceGte(value)
    }
    pub fn not(value: f64) -> WhereParam {
      WhereParam::PriceNot(value)
    }
    pub fn increment(value: f64) -> SetParam {
      SetParam::IncrementPrice(value)
    }
    pub fn decrement(value: f64) -> SetParam {
      SetParam::DecrementPrice(value)
    }
    pub fn multiply(value: f64) -> SetParam {
      SetParam::MultiplyPrice(value)
    }
    pub fn divide(value: f64) -> SetParam {
      SetParam::DividePrice(value)
    }
    pub struct Set(pub f64);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetPrice(value.0)
      }
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Price(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("price").build()
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Price(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("price").build()
      }
    }
  }
  pub mod date {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam
    };
    pub fn set<T: From<Set>>(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ) -> T {
      Set(value).into()
    }
    pub fn equals(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ) -> WhereParam {
      WhereParam::DateEquals(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Date(direction)
    }
    pub fn in_vec(
      value: Vec<
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset
        >
      >
    ) -> WhereParam {
      WhereParam::DateInVec(value)
    }
    pub fn not_in_vec(
      value: Vec<
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset
        >
      >
    ) -> WhereParam {
      WhereParam::DateNotInVec(value)
    }
    pub fn lt(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ) -> WhereParam {
      WhereParam::DateLt(value)
    }
    pub fn lte(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ) -> WhereParam {
      WhereParam::DateLte(value)
    }
    pub fn gt(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ) -> WhereParam {
      WhereParam::DateGt(value)
    }
    pub fn gte(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ) -> WhereParam {
      WhereParam::DateGte(value)
    }
    pub fn not(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ) -> WhereParam {
      WhereParam::DateNot(value)
    }
    pub struct Set(
      pub  ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    );
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetDate(value.0)
      }
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Date(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("date").build()
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Date(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::Selection::builder("date").build()
      }
    }
  }
  pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
    ["id", "food_type", "name", "price", "date"]
      .into_iter()
      .map(|o| {
        let builder = ::prisma_client_rust::Selection::builder(o);
        builder.build()
      })
      .collect()
  }
  pub fn create(
    food_type: String,
    name: String,
    price: f64,
    date: ::prisma_client_rust::chrono::DateTime<
      ::prisma_client_rust::chrono::FixedOffset
    >,
    _params: Vec<SetParam>
  ) -> (
    String,
    String,
    f64,
    ::prisma_client_rust::chrono::DateTime<
      ::prisma_client_rust::chrono::FixedOffset
    >,
    Vec<SetParam>
  ) {
    (food_type, name, price, date, _params)
  }
  #[macro_export]
  macro_rules ! _select_food { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: food :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: food :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: food :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: food :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: food :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: food :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , food_type , name , price , date } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { $ (pub $ field : $ crate :: prisma :: food :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (food_type) , stringify ! (name) , stringify ! (price) , stringify ! (date)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: food :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: food :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: food :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: food :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: food :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "food_type" , "name" , "price" , "date"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: food :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; food_type) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; price) => { f64 } ; (@ field_type ; date) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Food" , available fields are "id, food_type, name, price, date")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: food :: SelectParam > :: into ($ crate :: prisma :: food :: id :: Select) } ; (@ selection_field_to_selection_param ; food_type) => { Into :: < $ crate :: prisma :: food :: SelectParam > :: into ($ crate :: prisma :: food :: food_type :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: food :: SelectParam > :: into ($ crate :: prisma :: food :: name :: Select) } ; (@ selection_field_to_selection_param ; price) => { Into :: < $ crate :: prisma :: food :: SelectParam > :: into ($ crate :: prisma :: food :: price :: Select) } ; (@ selection_field_to_selection_param ; date) => { Into :: < $ crate :: prisma :: food :: SelectParam > :: into ($ crate :: prisma :: food :: date :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: food :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; food_type) => { "food_type" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; date) => { "date" } ; }
  pub use _select_food as select;
  pub enum SelectParam {
    Id(id::Select),
    FoodType(food_type::Select),
    Name(name::Select),
    Price(price::Select),
    Date(date::Select)
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::FoodType(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Price(data) => data.to_selection(),
        Self::Date(data) => data.to_selection()
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_food { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: food :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: food :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: food :: _outputs () ; selections . extend ($ crate :: prisma :: food :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: food :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: food :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: food :: _outputs () ; selections . extend ($ crate :: prisma :: food :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug)] pub struct Data { pub id : i32 , pub food_type : String , pub name : String , pub price : f64 , pub date : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: food :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (food_type) , stringify ! (name) , stringify ! (price) , stringify ! (date)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; food_type) , & self . food_type) ? ; state . serialize_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; price) , & self . price) ? ; state . serialize_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; date) , & self . date) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , food_type , name , price , date } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: food :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: food :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: food :: include ! (@ field_serde_name ; food_type) , ", " , $ crate :: prisma :: food :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: food :: include ! (@ field_serde_name ; price) , ", " , $ crate :: prisma :: food :: include ! (@ field_serde_name ; date) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: food :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: food :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: food :: include ! (@ field_serde_name ; food_type) => Ok (Field :: food_type) , $ crate :: prisma :: food :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: food :: include ! (@ field_serde_name ; price) => Ok (Field :: price) , $ crate :: prisma :: food :: include ! (@ field_serde_name ; date) => Ok (Field :: date) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut food_type = None ; let mut name = None ; let mut price = None ; let mut date = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: food_type => { if food_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; food_type))) ; } food_type = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: price => { if price . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; price))) ; } price = Some (map . next_value () ?) ; } Field :: date => { if date . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; date))) ; } date = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; id))) ? ; let food_type = food_type . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; food_type))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; name))) ? ; let price = price . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; price))) ? ; let date = date . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: food :: include ! (@ field_serde_name ; date))) ? ; Ok (Data { id , food_type , name , price , date , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "food_type" , "name" , "price" , "date"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: food :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Food" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: food :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; food_type) => { "food_type" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; price) => { "price" } ; (@ field_serde_name ; date) => { "date" } ; }
  pub use _include_food as include;
  pub enum IncludeParam {
    Id(id::Include),
    FoodType(food_type::Include),
    Name(name::Include),
    Price(price::Include),
    Date(date::Include)
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::FoodType(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Price(data) => data.to_selection(),
        Self::Date(data) => data.to_selection()
      }
    }
  }
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "food_type")]
    pub food_type: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "price")]
    pub price: f64,
    #[serde(rename = "date")]
    pub date: ::prisma_client_rust::chrono::DateTime<
      ::prisma_client_rust::chrono::FixedOffset
    >
  }
  impl Data {}
  #[derive(Clone)]
  pub enum WithParam {}
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {}
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    SetFoodType(String),
    SetName(String),
    SetPrice(f64),
    IncrementPrice(f64),
    DecrementPrice(f64),
    MultiplyPrice(f64),
    DividePrice(f64),
    SetDate(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    )
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64)) , SetParam :: IncrementId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: DecrementId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: MultiplyId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: DivideId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: SetFoodType (value) => ("food_type" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetName (value) => ("name" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) , SetParam :: IncrementPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DecrementPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: MultiplyPrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: DividePrice (value) => ("price" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , SetParam :: SetDate (value) => ("date" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Id(::prisma_client_rust::Direction),
    FoodType(::prisma_client_rust::Direction),
    Name(::prisma_client_rust::Direction),
    Price(::prisma_client_rust::Direction),
    Date(::prisma_client_rust::Direction)
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Id(direction) => (
          "id".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string())
        ),
        Self::FoodType(direction) => (
          "food_type".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string())
        ),
        Self::Name(direction) => (
          "name".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string())
        ),
        Self::Price(direction) => (
          "price".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string())
        ),
        Self::Date(direction) => (
          "date".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string())
        )
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    IdEquals(i32),
    IdInVec(Vec<i32>),
    IdNotInVec(Vec<i32>),
    IdLt(i32),
    IdLte(i32),
    IdGt(i32),
    IdGte(i32),
    IdNot(i32),
    FoodTypeEquals(String),
    FoodTypeInVec(Vec<String>),
    FoodTypeNotInVec(Vec<String>),
    FoodTypeLt(String),
    FoodTypeLte(String),
    FoodTypeGt(String),
    FoodTypeGte(String),
    FoodTypeContains(String),
    FoodTypeStartsWith(String),
    FoodTypeEndsWith(String),
    FoodTypeMode(QueryMode),
    FoodTypeNot(String),
    NameEquals(String),
    NameInVec(Vec<String>),
    NameNotInVec(Vec<String>),
    NameLt(String),
    NameLte(String),
    NameGt(String),
    NameGte(String),
    NameContains(String),
    NameStartsWith(String),
    NameEndsWith(String),
    NameMode(QueryMode),
    NameNot(String),
    PriceEquals(f64),
    PriceInVec(Vec<f64>),
    PriceNotInVec(Vec<f64>),
    PriceLt(f64),
    PriceLte(f64),
    PriceGt(f64),
    PriceGte(f64),
    PriceNot(f64),
    DateEquals(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ),
    DateInVec(
      Vec<
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset
        >
      >
    ),
    DateNotInVec(
      Vec<
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset
        >
      >
    ),
    DateLt(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ),
    DateLte(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ),
    DateGt(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ),
    DateGte(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    ),
    DateNot(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >
    )
  }
  impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
    fn into(self) -> ::prisma_client_rust::SerializedWhere {
      match self { Self :: Not (value) => :: prisma_client_rust :: SerializedWhere :: new ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: Or (value) => :: prisma_client_rust :: SerializedWhere :: new ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => :: prisma_client_rust :: SerializedWhere :: new ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (value . into_iter () . map (Into :: < :: prisma_client_rust :: SerializedWhere > :: into) . map (Into :: into) . collect ()) ,) , Self :: IdEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , Self :: IdInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Int (v as i64)) . collect ()))])) , Self :: IdNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Int (v as i64)) . collect ()))])) , Self :: IdLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , Self :: IdLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , Self :: IdGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , Self :: IdGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , Self :: IdNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , Self :: FoodTypeEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: FoodTypeNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: FoodTypeLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: FoodTypeMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: FoodTypeNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("food_type" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: NameNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))])) , Self :: NameLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameContains (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameStartsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameEndsWith (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: NameMode (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))])) , Self :: NameNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("name" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: PriceEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PriceNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (v) . unwrap () . normalized ())) . collect ()))])) , Self :: PriceLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: PriceNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("price" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))])) , Self :: DateEquals (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) , Self :: DateInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))])) , Self :: DateNotInVec (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))])) , Self :: DateLt (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) , Self :: DateLte (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) , Self :: DateGt (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) , Self :: DateGte (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) , Self :: DateNot (value) => :: prisma_client_rust :: SerializedWhere :: new ("date" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) }
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    IdEquals(i32)
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value)
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value)
      }
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<
    WhereParam,
    WithParam,
    OrderByParam,
    UniqueWhereParam
  >;
  pub type Count<'a> =
    ::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
  pub type Create<'a> =
    ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
  pub type FindUnique<'a> =
    ::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<
    'a,
    WhereParam,
    WithParam,
    OrderByParam,
    UniqueWhereParam,
    SetParam,
    Data
  >;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
    'a,
    WhereParam,
    WithParam,
    OrderByParam,
    UniqueWhereParam,
    Data
  >;
  pub type Update<'a> =
    ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
  pub type UpdateMany<'a> =
    ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
  pub type Upsert<'a> =
    ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
  pub type Delete<'a> =
    ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
  pub struct Actions<'a> {
    pub client: &'a PrismaClient
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where.into()
      )
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where
      )
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where
      )
    }
    pub fn create(
      self,
      food_type: String,
      name: String,
      price: f64,
      date: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset
      >,
      mut _params: Vec<SetParam>
    ) -> Create<'a> {
      _params.push(food_type::set(food_type));
      _params.push(name::set(name));
      _params.push(price::set(price));
      _params.push(date::set(date));
      Create::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _params
      )
    }
    pub fn create_many(
      self,
      data: Vec<(
        String,
        String,
        f64,
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset
        >,
        Vec<SetParam>
      )>
    ) -> CreateMany<'a> {
      let data = data
        .into_iter()
        .map(|(food_type, name, price, date, mut _params)| {
          _params.push(food_type::set(food_type));
          _params.push(name::set(name));
          _params.push(price::set(price));
          _params.push(date::set(date));
          _params
        })
        .collect();
      CreateMany::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        data
      )
    }
    pub fn update(
      self,
      _where: UniqueWhereParam,
      _params: Vec<SetParam>
    ) -> Update<'a> {
      Update::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where.into(),
        _params,
        vec![]
      )
    }
    pub fn update_many(
      self,
      _where: Vec<WhereParam>,
      _params: Vec<SetParam>
    ) -> UpdateMany<'a> {
      UpdateMany::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where,
        _params
      )
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (food_type, name, price, date, mut _params): (
        String,
        String,
        f64,
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset
        >,
        Vec<SetParam>
      ),
      _update: Vec<SetParam>
    ) -> Upsert<'a> {
      _params.push(food_type::set(food_type));
      _params.push(name::set(name));
      _params.push(price::set(price));
      _params.push(date::set(date));
      Upsert::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where.into(),
        _params,
        _update
      )
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where.into(),
        vec![]
      )
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        _where.into()
      )
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(
        self.client._new_query_context(),
        ::prisma_client_rust::QueryInfo::new("Food", _outputs()),
        vec![]
      )
    }
  }
}
pub mod _prisma {
  pub struct PrismaClient {
    executor: ::prisma_client_rust::Executor,
    query_schema: ::std::sync::Arc<::prisma_client_rust::schema::QuerySchema>
  }
  impl ::std::fmt::Debug for PrismaClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
      f.debug_struct("PrismaClient").finish()
    }
  }
  impl PrismaClient {
    pub(super) fn _new_query_context(
      &self
    ) -> ::prisma_client_rust::queries::QueryContext {
      ::prisma_client_rust::queries::QueryContext::new(
        &self.executor,
        &self.query_schema
      )
    }
    pub(super) fn _new(
      executor: ::prisma_client_rust::Executor,
      query_schema: std::sync::Arc<::prisma_client_rust::schema::QuerySchema>
    ) -> Self {
      Self {
        executor,
        query_schema
      }
    }
    pub fn _query_raw<T: serde::de::DeserializeOwned>(
      &self,
      query: ::prisma_client_rust::raw::Raw
    ) -> ::prisma_client_rust::QueryRaw<T> {
      ::prisma_client_rust::QueryRaw::new(
        ::prisma_client_rust::queries::QueryContext::new(
          &self.executor,
          &self.query_schema
        ),
        query,
        super::DATABASE_STR
      )
    }
    pub fn _execute_raw(
      &self,
      query: ::prisma_client_rust::raw::Raw
    ) -> ::prisma_client_rust::ExecuteRaw {
      ::prisma_client_rust::ExecuteRaw::new(
        ::prisma_client_rust::queries::QueryContext::new(
          &self.executor,
          &self.query_schema
        ),
        query,
        super::DATABASE_STR
      )
    }
    pub async fn _batch<
      T: ::prisma_client_rust::BatchContainer<Marker>,
      Marker
    >(
      &self,
      queries: T
    ) -> ::prisma_client_rust::queries::Result<T::ReturnType> {
      ::prisma_client_rust::batch(queries, &self.executor, &self.query_schema)
        .await
    }
    pub fn food(&self) -> super::food::Actions {
      super::food::Actions { client: &self }
    }
  }
  #[derive(
    Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize,
  )]
  pub enum FoodScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "food_type")]
    FoodType,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "price")]
    Price,
    #[serde(rename = "date")]
    Date
  }
  impl ToString for FoodScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::FoodType => "food_type".to_string(),
        Self::Name => "name".to_string(),
        Self::Price => "price".to_string(),
        Self::Date => "date".to_string()
      }
    }
  }
  #[derive(
    Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize,
  )]
  pub enum QueryMode {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "insensitive")]
    Insensitive
  }
  impl ToString for QueryMode {
    fn to_string(&self) -> String {
      match self {
        Self::Default => "default".to_string(),
        Self::Insensitive => "insensitive".to_string()
      }
    }
  }
  #[derive(
    Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize,
  )]
  pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc
  }
  impl ToString for SortOrder {
    fn to_string(&self) -> String {
      match self {
        Self::Asc => "asc".to_string(),
        Self::Desc => "desc".to_string()
      }
    }
  }
  #[derive(
    Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize,
  )]
  pub enum TransactionIsolationLevel {
    #[serde(rename = "ReadUncommitted")]
    ReadUncommitted,
    #[serde(rename = "ReadCommitted")]
    ReadCommitted,
    #[serde(rename = "RepeatableRead")]
    RepeatableRead,
    #[serde(rename = "Serializable")]
    Serializable
  }
  impl ToString for TransactionIsolationLevel {
    fn to_string(&self) -> String {
      match self {
        Self::ReadUncommitted => "ReadUncommitted".to_string(),
        Self::ReadCommitted => "ReadCommitted".to_string(),
        Self::RepeatableRead => "RepeatableRead".to_string(),
        Self::Serializable => "Serializable".to_string()
      }
    }
  }
}
pub use _prisma::PrismaClient;
